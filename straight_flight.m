%% straight flight script 8/10/21
%% add uncertainty due to azure cameras
%% plot have to be publication quality, same axes and latex and good colors, PDF
%% fitting the angles, get first and second derivative as for acceleration
%% How do I evaluate the velocity and acceleration from differentiate() compared to the values from finite difference of experimental data? adjrsquare
%% add theta and theta prime

%% savitzky-golay for raw data, velocity, acceleration etc...
%% fitted curve going to inf at the edges...
%% strating point in fitting changes with every flight...

%% X direction of flight
%% Y laterak direction
%% Z vertical direction
clear all; close all; clc;

tic();
%% code for figures sent by Anjali on Slack 15/1/20, updated for this release and set(groot, ...)
%% for plots use either this or graph_settings.m sent by Pisetta on Slack
f=12;
set(groot, 'defaultAxesTickLabelInterpreter', 'latex'); 
set(groot, 'defaultLegendInterpreter', 'latex');
set(0,'defaultTextInterpreter','latex');
set(0, 'defaultAxesFontSize', f)
set(0, 'defaultLegendFontSize', f)
set(0, 'defaultAxesFontName', 'Times New Roman');
set(0, 'defaultLegendFontName', 'Times New Roman');
set(0, 'DefaultLineLineWidth', 1.0);
paperUnits = 'centimeters';
paperPosition = [0 0 15 7.5];

% first frame 
in = 106;
fin = in + 15;
% last frame 
% fin = 186;

length = fin-in+1; 
% frame rate is 30 fps (if it is not constant it gives noise on the data
% dor velocity etc...)
fps = 30;
% time between two frames [s]
time = 1/fps;
% time interval [s], of the flight (initial time - final time)
Dt = round(time*(length),4);

% path to save the figures generated by the code
% https://uk.mathworks.com/matlabcentral/answers/396942-how-to-create-a-new-folder-mkdir-but-naming-that-folder-as-input-before-running-the-code
% % % pname = '/Volumes/Seagate/Meeting_IMV/XY_XZ_U_Theta_ThetaPrime/Alsomitra01';
% % % dname = 'Data05Second';

% generate the folder 
% % % mkdir(fullfile(pname,dname))

% input folder with the .txt files from the experiment
inputFolder = '/Volumes/Seagate/Azure_kinect/Classroom3SandersonBld/Experiment_DataCollected/_____________SetUpStraightFlight/Alsomitra26/Data02/2PtCloud';

%% initialized vectors and matrices
coord_2 = zeros(20,3);

% length = fin-in+1; 
ptCloudRoiPoints = zeros(1,length); %ptCloudRoiPoints = zeros(1,fin-in+1);
ptCloudDeNoisePoints = zeros(1,length); %ptCloudDeNoisePoints = zeros(1,fin-in+1);
r = zeros(1,length); %r = zeros(1,fin-in+1);
denoiseboxsize = zeros(length,3); %denoiseboxsize = zeros(fin-in+1,3);
x_centroid = zeros(length,1); %x_centroid = zeros(fin-in+1,1);
y_centroid = zeros(length,1); %y_centroid = zeros(fin-in+1,1);
z_centroid = zeros(length,1); %z_centroid = zeros(fin-in+1,1);
centroid = zeros(length,3); %centroid = zeros(fin-in+1,3);

% allocating array of PointCloud, it is not a struct
% errore: Assignment between unlike types is not allowed.
% nomestruttura(dimensione).campo1 = [];
% total number of points in the PtCloud
TotPtCloud = 737280;

RotPtCloud(TotPtCloud,3).Location = [];
% ROTPTCLOUD.Count = [];
RotPtCloud(1,2).XLimits = [];
RotPtCloud(1,2).YLimits = [];
RotPtCloud(1,2).ZLimits = [];
RotPtCloud(TotPtCloud,3).Color = [];
% RotPtCloud(length).Normal = [];
% RotPtCloud(length).Intensity = [];

% % I do not know the size of the denoised point cloud so I pre-allocate more
% % than needed
ReductionDeNoise = 50;
RowsDeNoiseIni = round(TotPtCloud/ReductionDeNoise,0);

ptCloudDeNoise(RowsDeNoiseIni,3).Location = [];
% ptCloudDeNoise(length).Count = [];
ptCloudDeNoise(1,2).XLimits = [];
ptCloudDeNoise(1,2).YLimits = [];
ptCloudDeNoise(1,2).ZLimits = [];
ptCloudDeNoise(RowsDeNoiseIni,3).Color = [];
% ptCloudDeNoise(length).Normal = [];
% ptCloudDeNoise(length).Intensity = [];

ptCloud_cuboid_angles = zeros(length,3); %ptCloud_cuboid_angles = zeros(fin-in+1,3);

% x axis vector
Xaxis = [1 0 0];
% y axis vector
Yaxis = [0 1 0];
% z axis vector
Zaxis = [0 0 1];

% merge the pointclouds from the 2 cameras;
addpath /Users/danielecertini/Documents/MATLAB/Alsomitra_macrocarpa/3D_tracking_Yang/testD

w = 2048;
h = 1536;

coord_1 = load('/Volumes/Seagate/testD/Data/2Dto3DCalib1_2.txt');
coord_2_old = load('/Volumes/Seagate/testD/Data/2Dto3DCalib2_2.txt');

for j = in:fin
    %% index used to get the right size for vectors and matrix later exported
    l = j - in + 1;
    
    newIndex=[16:20, 11:15, 6:10, 1:5];
%     coord_2 = zeros(20,3); initialized outside
    for i=1:20
        coord_2(i,:)=coord_2_old(newIndex(i),:);
    end
    
    silicone = load([inputFolder,num2str(j),'.txt']);
    bottle_1 = silicone(:,1:7);
    bottle_2 = silicone(:,8:14);
    
    [R,T] = FindTrans(coord_1, coord_2);
    % I think bottle_1 is the one transformed
    bottle_1_new = bottle_1(:,1:3) * R' + repmat(T', size(bottle_1,1), 1);
    coord_1_new = coord_1 * R' + repmat(T', size(coord_1,1), 1);
    e = coord_1_new - coord_2;
    
% %   It shows the 2 merged point clouds
%     figure('color','k');
%     pcshow(pointCloud(bottle_1_new(:,1:3), 'Color', bottle_1(:,4:6)./255))
%     hold on
%     pcshow(pointCloud(bottle_2(:,1:3), 'Color', bottle_2(:,4:6)./255))
%     hold off
%     title(['Merged Point Clouds',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    
%   New point cloud merging [bottle_1_new,bottle_2]
    pointData1 = bottle_1_new;
    colorData1 = bottle_1(:,4:6);
    ColorPointCloud1 = pointCloud(pointData1, 'Color', colorData1./255);% bottle_2(1:3), bottle_2(:,4:6)./255];
    
% %   Point cloud from camera 1, closest to release point
%     figure;
%     pcshow(ColorPointCloud1)
%     title(['Camera 1, first part flight path',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    
    pointData2 = bottle_2(:,1:3);
    colorData2 = bottle_2(:,4:6);
    ColorPointCloud2 = pointCloud(pointData2, 'Color', colorData2./255);% bottle_2(1:3), bottle_2(:,4:6)./255];
   
% %   Point cloud from camera 2, closest to lainding site
%     figure;
%     pcshow(ColorPointCloud2)
%     title(['Camera 2, second part flight path',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    
    pointData = [bottle_1_new; bottle_2(:,1:3)];
    colorData = [bottle_1(:,4:6); bottle_2(:,4:6)];
    % in [mm]
    ColorPointCloud = pointCloud(pointData,'Color',colorData./255);
    % in [m]
    % ColorPointCloudMeters = pointCloud(ColorPointCloud.Location/10^3,'Color',colorData./255);
    
% %   2 point clouds merged
%     figure;
%     % in [mm]
%     pcshow(ColorPointCloud)
%     % in [m]
%     % pcshow(ColorPointCloudMeters)
%     hold on
%     plot3(0,0,0,'.r')
%     hold off
%     title(['2 Point Clouds merged',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    
    % https://uk.mathworks.com/help/vision/ref/pcfitplane.html
    % Set the maximum point-to-plane distance in [mm] for plane fitting.
    % Maximum distance from an inlier point to the plane, specified as a scalar value.
    % Specify the distance in units that are consistent with the units you are using for the point cloud.
    maxDistance = 3;
    
    % Set the normal vector of the plane.
    referenceVector = [0,0,1];
    
    % Set the maximum angular distance in degrees.
    maxAngularDistance = 9;
    
    [model1,inlierIndices] = pcfitplane(ColorPointCloud,...
        maxDistance,referenceVector,maxAngularDistance);
    
    % Detect the first plane, the table, and extract it from the point cloud.
    plane1 = select(ColorPointCloud,inlierIndices);
    
%     % plane fitting the ground
%     figure
%     pcshow(plane1)
%     title(['Ground plane fitting',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')

    % https://uk.mathworks.com/help/vision/ref/pctransform.html
    % rotation of the original point cloud around X axis vertical axis is z
    y_rotX = abs(max(plane1.YLimits) - min(plane1.YLimits));
    z_rotX = abs(max(plane1.ZLimits) - min(plane1.ZLimits));
    rotX = - atan(z_rotX/y_rotX) - pi;
    
    % rotation matrix around X axis
    % https://uk.mathworks.com/help/images/matrix-representation-of-geometric-transformations.html
    RX = [1,         0,         0, 0;
        0, cos(rotX), sin(rotX), 0;
        0,-sin(rotX), cos(rotX), 0;
        0,          0,        0, 1];
    
    tformRX = affine3d(RX);
    
    % transformation of the ground
    ptCloudRotX = pctransform(plane1, tformRX);
    % just to visually check in the figure
    ptCloudRotFullX = pctransform(ColorPointCloud, tformRX);
    
%     %   First rotation, around X axis
%     figure
%     pcshow(ptCloudRotFullX);
%     title(['Rotation X axis ground',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    
    % rotation of the rotated point cloud around Y axis
    x_rotY = abs(max(ptCloudRotX.XLimits) - min(ptCloudRotX.XLimits));
    z_rotY = abs(max(ptCloudRotX.ZLimits) - min(ptCloudRotX.ZLimits));
    rotY = -atan(z_rotY/x_rotY);
    
    % rotation matrix, around Y axis
    % https://uk.mathworks.com/help/images/matrix-representation-of-geometric-transformations.html
    RY = [cos(rotY),         0, -sin(rotY), 0;
        0,             1,              0, 0;
        sin(rotY),         0,  cos(rotY), 0;
        0,          0,     0,             1];
    
    tformRY = affine3d(RY);
    
    % point cloud rotated around x (previously), now around y
    ptCloudRotY = pctransform(ptCloudRotX, tformRY);
    ptCloudRotFullY = pctransform(ptCloudRotFullX, tformRY);
    
%     % Second rotation, around Y axis
%     figure
%     pcshow(ptCloudRotFullY);
%     title(['Rotation Y axis ground, final rotation',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
        
    % Create a displacement field D of same size as the point cloud
    D = zeros(size(ColorPointCloud.Location));
    
    % Set the displacement field value along z-axis;
    D(:,3) = - max(ptCloudRotY.ZLimits);
    
    % transform the point cloud;
    RotPtCloud = pctransform(ptCloudRotFullY,D);
    
    
 
    %% save the coordinates, I will be able to start the calculation from here and save time
    ROTPTCLOUD(l) = RotPtCloud;
    
    
    
%     % Translation of the rotated point cloud to put the origin on the ground
%     figure
%     pcshow(RotPtCloud);
%     title(['Rotated around X and Y, translated on Z',' ',num2str(j)],'FontSize',f)
%     axis equal
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')

    % build a region of interest ROI;
    roi = [-900 500 -1000 1000 200 1500];
    
    %Find the indices of the points that lie within the cuboid ROI.
    indices = findPointsInROI(RotPtCloud,roi);
    
    %Select the points that lie within the cuboid ROI and store as a point cloud object.
    ptCloudRoi = select(RotPtCloud,indices);
    
%     %Display the input point cloud and the point cloud within the specified ROI.
%     % This figure is important to judge the data quality
%     figure
%     pcshow(RotPtCloud.Location,[0.5 0.5 0.5])
%     hold on
%     pcshow(ptCloudRoi.Location,'r');
%     plotcube([abs(roi(1)-roi(2)) abs(roi(3)-roi(4)) abs(roi(5)-roi(6))],[roi(1) roi(3) roi(5)],.2,[0 1 0]);
%     %axis(roi*1.5);
%     %axis(roi);
%     %axis equal
%     axis([-1500 1500 -1500 1500 -1500 1500])
%     legend('Point Cloud','Points within ROI','Location','southoutside','Color',[1 1 1],'FontSize',f)
%     title(['Point Cloud in ROI',' ',num2str(j)],'FontSize',f)
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
%     hold off
     
    % count the number of points in roi, save the it in row vector
    ptCloudRoiPoints(l) = ptCloudRoi.Count;
    
    % Denoise, remove noise from the point cloud belonging to the ROI
    % I have 10 points I take each individual point and calculate the average distance to the remaining 9 points. I then average this
    % number so sum of all the distances divided by 10 to get the mean of the average distance. By default, the threshold is one 
    % standard deviation from the mean of the average distance to neighbors of all points. 
    % A point is considered to be an outlier if the average distance to its k-nearest neighbors is above the specified threshold.
    % threshold, minimum number of points in ROI to perform denoising
    if ptCloudRoi.Count >= 10
    % IMV suggested to use full Point Cloud for 'NumNeighbors',round(ptCloudRoi.Count,0)
%     [ptCloudDeNoise,inlierIndices,outlierIndices] = pcdenoise(ptCloudRoi,'NumNeighbors',round(ptCloudRoi.Count/10,0),'Threshold',0);
    [ptCloudDeNoise,inlierIndices,outlierIndices] = pcdenoise(ptCloudRoi,'NumNeighbors',round(ptCloudRoi.Count/10,0),'Threshold',0);
    else 
    ptCloudDeNoise = ptCloudRoi;
    end
    
    %% save the denoised point cloud
    PTCLOUDDENOISE(l) = ptCloudDeNoise;
  
    % count number of points of denoised point cloud
    ptCloudDeNoisePoints(l) = ptCloudDeNoise.Count;
    
    % test the quality of denoising
    r(l) = ptCloudRoi.Count/ptCloudDeNoise.Count;
    % save size of the bounding box from ptCloudDeNoise to get an idea of the noise level left
    DeNoiseBoxLimits = [ptCloudDeNoise.XLimits ptCloudDeNoise.YLimits ptCloudDeNoise.ZLimits];
    % stops the code Index exceeds the number of array elements (0).
    %     DeNoiseBoxSize = [abs(DeNoiseBoxLimits(1)-DeNoiseBoxLimits(2)) abs(DeNoiseBoxLimits(3)-DeNoiseBoxLimits(4)) abs(DeNoiseBoxLimits(5)-DeNoiseBoxLimits(6))];
    %     denoiseboxsize(l,:) = DeNoiseBoxSize;
    
%     % display denoised point cloud about Alsomitra inside the full point cloud
%     figure
%     pcshow(RotPtCloud.Location,[0.5 0.5 0.5])
%     hold on
%     pcshow(ptCloudDeNoise.Location,[1 0 0]);
%     title(['ROI and Denoised',' ',num2str(j)],'FontSize',f)
%     %axis equal
%     %axis([-500 500 -1000 500 500 1500])
%     axis([-1500 1500 -1500 1500 -1500 1500])
%     xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
%     ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
%     zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')mm]')
%     hold off
    
    %% not using pcmedian
    % ptCloudMedian = pcmedian(ptCloudDeNoise,'Dimension',3,'Radius',DeNoiseBox(3)/2);
    
    % Get the centroid from averaging the coordinates
    [ptCloudDeNoise_r,ptCloudDeNoise_c] = size(ptCloudDeNoise.Location);
    x_centroid = sum(ptCloudDeNoise.Location(:,1),1)/ptCloudDeNoise_r;
    y_centroid = sum(ptCloudDeNoise.Location(:,2),1)/ptCloudDeNoise_r;
    z_centroid = sum(ptCloudDeNoise.Location(:,3),1)/ptCloudDeNoise_r;
    centroid(l,:) = [x_centroid y_centroid z_centroid];
end
% NaN values from rows of centroid
centroid = rmmissing(centroid,1,'MinNumMissing',1);

%% remove the outliers, values of x,y,z when z~=0
x_centroid = x_centroid(z_centroid~=0);
y_centroid = y_centroid(z_centroid~=0);
z_centroid = z_centroid(z_centroid~=0);

%% plot fitting line 
% https://math.stackexchange.com/questions/268528/fitting-a-3d-line-to-a-3d-line-point-cloud
x_centroid_mean = mean(centroid(:,1));
y_centroid_mean = mean(centroid(:,2));
z_centroid_mean = mean(centroid(:,3));

x_centroid_new = centroid(:,1) - x_centroid_mean;
y_centroid_new = centroid(:,2) - y_centroid_mean;
z_centroid_new = centroid(:,3) - z_centroid_mean;

xyz_centroid_new = [x_centroid_new y_centroid_new z_centroid_new];

% to evaluate the quality of the point cloud I plot the number of original points versus the frame number and denoised point cloud vs frames 
% the frequency of this signal might be similar to the one of the flight path
figure
plot(ptCloudRoiPoints,'or')
hold on
plot(ptCloudDeNoisePoints,'.b')
axis square
title(['Number of points in Alsomitra point cloud',' ',num2str(fin-in+1),' ','frames'],'FontSize',f)
xlabel('Frame','FontSize',f)
ylabel('Points','FontSize',f)
% legend('ROI','final')
hold off
% save the figure above
% % % savefig(fullfile(pname,dname,'PointsFullPtCloudOverDenoised.fig'))

% cscvn works with the transpose
centroid_cscvn = centroid';

% Shows the position of fin-in+1 centroids (a centroid per frame)
% add smoothing spline
figure
pcshow(RotPtCloud);
hold on
fnplt(cscvn(centroid_cscvn(:,1:end)),'r',2);
% plot3(xccc,yccc,zccc,'co')
axis([-1500 1400 -1400 1200 -200 1500])
% swap x and y
title('Centroid of Point Cloud in all frames','FontSize',f)
xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')mm]')
hold off
% save the figure above
% % % savefig(fullfile(pname,dname,'Centroid_PtCloud_fullframes.fig'))

% fitting a line through the point cloud
% https://uk.mathworks.com/matlabcentral/answers/494646-3-d-line-of-best-fit-from-origin-to-cloud-of-data-points
% https://math.stackexchange.com/questions/268528/fitting-a-3d-line-to-a-3d-line-point-cloud

[V,d] = eig(xyz_centroid_new.'*xyz_centroid_new,'vector');
[~,i] = max(d);
u = V(:,i);
t = 1.5*min(xyz_centroid_new,[],'all'):0.1:1.5*max(xyz_centroid_new,[],'all');

v = eye(3);
% written with Mahdi 
uxy = [u(1);u(2)];
Xaxis2 = [1 0];
CosTheta = max(min(dot(Xaxis2,uxy)/(norm(uxy)*norm(Xaxis2)),1),-1);
% angle between the straight line and the YZ plane
ThetaInDegrees = - 90 + real(acosd(CosTheta));
% perform the rigid rotation around Z axis
RotZmat = rotz(ThetaInDegrees);
% Turn the straight line
uRotz = RotZmat*u;
% Turn the point cloud
xyzRotZ = RotZmat*xyz_centroid_new';

figure
plot3(xyzRotZ(1,:),xyzRotZ(2,:),xyzRotZ(3,:),'ob',uRotz(1)*t,uRotz(2)*t,uRotz(3)*t,0,0,0,'.g');
hold on
fnplt(cscvn(xyzRotZ(:,1:end)),'k',2)
xline(0,'Color','g')
yline(0,'Color','g')
axis equal
title(['Flight path and sraight line fitting',' ',num2str(j)],'FontSize',f)
% swap x and y
xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
% view(0,90)
hold off
% % % % save the figure above
% % % % % % savefig(fullfile(pname,dname,'FlightPathAndFittedLine.fig'))

% centroid coordinates in the rotated reference frame, almost 2D
xyz_centroid_rot = xyzRotZ';
[r_centroid,c_centroid] = size(xyz_centroid_rot);

x_centroid_rot = xyz_centroid_rot(:,1); 
y_centroid_rot = xyz_centroid_rot(:,2); 
z_centroid_rot = xyz_centroid_rot(:,3); 

% plot y-z, x-z  and 3D (requested by Ignazio)
%% ripartire da qui 22/09/21, fatto 
%% requested by IMV on SLack 15/09/21
figure
plot(y_centroid_rot+abs(min(y_centroid_rot)),z_centroid_rot+abs(min(z_centroid_rot)),'.')
yline(0)
axis equal
title('Descent path on XZ plane','FontSize',f)
% swap x and y
xlabel('$x$ [mm]','FontSize',f) %xlabel('x [mm]')
ylabel('$z$ [mm]','FontSize',f) %ylabel('y [mm]')
% save the figure above
% savefig(fullfile(pname,dname,'DescentXZ.fig'));

figure
plot(x_centroid_rot-x_centroid_rot(1),z_centroid_rot+abs(min(z_centroid_rot)),'.')
xline(0)
axis equal
title('Descent path on YZ plane','FontSize',f)
% swap x and y
xlabel('$y$ [mm]','FontSize',f)
ylabel('$z$ [mm]','FontSize',f)
hold off
% save the figure above
% savefig(fullfile(pname,dname,'DescentYZ.fig'));

figure
plot3(x_centroid_rot-x_centroid_rot(1),y_centroid_rot+abs(min(y_centroid_rot)),z_centroid_rot+abs(min(z_centroid_rot)),'.')
xline(0)
axis equal
title('3D descent path','FontSize',f)
% swap x and y
xlabel('$y$ [mm]','FontSize',f)
ylabel('$x$ [mm]','FontSize',f)
zlabel('$z$ [mm]','FontSize',f)
hold off
% save the figure above
% savefig(fullfile(pname,dname,'ThreeDimDescent.fig'));

% might be unused, I do not find it anywhere else
% ttime = 1:fin-in+1;

Time = linspace(0,time*r_centroid,r_centroid);
dt = Time(2) - Time(1);

% check the fittings, move the plots and add savefig, fitresult is a cfit Class.
% this is the only place where I do the fitting, velocity and acceleration
% are the derivative of the fitted curve. To improve the fitting I exclude
% first 2 and last 2 points.

%% check how to set opts.StartPoint = [0 0 0 0 0 0 0 0 0 0 0 0 0 1.14936316594749];
[fitresultx, gofx] = FourierFit6(Time', x_centroid_rot, fittype('fourier6'));
[fitresulty, gofy] = FourierFit6(Time', y_centroid_rot, fittype('fourier6'));
[fitresultz, gofz] = FourierFit6(Time', z_centroid_rot, fittype('fourier6'));

% %% Time_2 updated and contrsint on gof for plane fitting
% % new time vector, x axis to get a better defined velocity
Time_2 = linspace(0,time*r_centroid,10^2);
p_x = coeffvalues(fitresultx);
w_x = fitresultx.w;
% x_filt = FourierFit_vector(p_x, w_x, Time_2);
x_filt = FourierFit6_vector(p_x, w_x, Time_2);

p_y = coeffvalues(fitresulty);
w_y = fitresulty.w;
% % y_filt = FourierFit_vector(p_y, w_y, Time_2);
y_filt = FourierFit6_vector(p_y, w_y, Time_2);

p_z = coeffvalues(fitresultz);
w_z = fitresultz.w;
% % z_filt = FourierFit_vector(p_z, w_z, Time_2);
z_filt = FourierFit6_vector(p_z, w_z, Time_2);

figure
plot3(x_centroid_rot,y_centroid_rot,z_centroid_rot,'ok')
hold on
plot3(x_filt,y_filt,z_filt,'k')
title('Centroid of Point Cloud in all frames','FontSize',f)
% swap x and y
xlabel('$y$ [mm]','FontSize',f)
ylabel('$x$ [mm]','FontSize',f)
zlabel('$z$ [mm]','FontSize',f)
axis equal
hold off

% velocities [m/s], derivative of fitted functions. gradient calculates the central difference for interior data points
% https://uk.mathworks.com/help/matlab/ref/gradient.html
% x_velo = gradient(x_filt,dt);
% y_velo = gradient(y_filt,dt);
% z_velo = gradient(z_filt,dt);
% U_velo = sqrt(x_velo.^2 + y_velo.^2 + z_velo.^2);

% https://uk.mathworks.com/help/curvefit/differentiate.html
% works with the fitted curve
% x component of velocity [mm/s] and acceleration [m/s^2]
[fitfx, fitfxx] = differentiate(fitresultx, Time_2);
% y component of velocity [mm/s] and acceleration [m/s^2]
[fitfy, fitfyy] = differentiate(fitresulty, Time_2);
% x component of velocity [mm/s] and acceleration [m/s^2]
[fitfz, fitfzz] = differentiate(fitresultz, Time_2);
% U velocity magnitude [mm/s] and acceleration [m/s^2]
fitfU = sqrt(fitfx.^2 + fitfy.^2 + fitfz.^2);
% fitfU = sqrt(fitfx.^2 + fitfy.^2 + fitfz.^2);
fitfA = sqrt(fitfxx.^2 + fitfyy.^2 + fitfzz.^2);

% figure
% plot(Time_2,x_velo/10^3,'b',Time,x_velo_FinDiff/10^3,'or',Time_2,fitfx/10^3,'k')
% title('Velocity component u, fitting and finite difference')
% xlabel('Time [s]')
% ylabel('Velocity component u [m/s]')

% velocities [m/s], derivative of . gradient calculates the central difference for interior data points
% https://uk.mathworks.com/help/matlab/ref/gradient.html
% velocities [m/s], finite differences scheme
x_velo_FinDiff = gradient(x_centroid_rot,dt); 
y_velo_FinDiff = gradient(y_centroid_rot,dt); 
z_velo_FinDiff = gradient(z_centroid_rot,dt);
U_velo_FinDiff = sqrt(x_velo_FinDiff.^2 + y_velo_FinDiff.^2 + z_velo_FinDiff.^2);

%% need to find a way to deal with fitting curves at the 2 borders (too steep)
% dimensions are in [mm] so to get [m/s] I divide by 10^3

%% X is direction of flight, Y is lateral motion
figure
% plot(Time_2,x_velo/10^3,'r',Time_2,y_velo/10^3,'g',Time_2,z_velo/10^3,'b')
% hold on
plot(Time_2,fitfx/10^3,'.r',Time_2,fitfy/10^3,'.g',Time_2,fitfz/10^3,'.b')
yline(0)
title('Velocity components $u$, $v$, $w$ in rotated reference frame','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Velocity components [m/s]','FontSize',f)
legend('$v$','$u$','$w$','FontSize',f)
% hold off
% save the figure above
% % % savefig(fullfile(pname,dname,'VelComp.fig'));

figure
% plot(Time_2,x_velo/10^3,'r',Time_2,fitfx/10^3,'k',Time,x_velo_FinDiff/10^3,'.k')
plot(Time_2,fitfx/10^3,'k',Time,x_velo_FinDiff/10^3,'.k')
title('Velocity component $u$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Velocity component $v$ [m/s]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'VelComp_u.fig'));

figure
% plot(Time_2,y_velo/10^3,'g',Time_2,fitfy/10^3,'k',Time,y_velo_FinDiff/10^3,'.k')
plot(Time_2,fitfy/10^3,'k',Time,y_velo_FinDiff/10^3,'.k')
title('Velocity component $v$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Velocity component $u$ [m/s]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'VelComp_v.fig'));

figure
% plot(Time_2,z_velo/10^3,'b',Time_2,fitfz/10^3,'k',Time,z_velo_FinDiff/10^3,'.k')
plot(Time_2,fitfz/10^3,'k',Time,z_velo_FinDiff/10^3,'.k')
title('Velocity component $w$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Velocity component $w$ [m/s]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'VelComp_w.fig'));

figure
% plot(Time_2,fitfU/10^3,Time_2,U_velo/10^3,Time,U_velo_FinDiff/10^3,'.k')
plot(Time_2,fitfU/10^3,Time,U_velo_FinDiff/10^3,'.k')
% plot(Time_2,fitfU/10^3)
% hold on
% plot(Time(1:end-2),U_velo_FinDiff(1:end-2)/10^3,'.k')
title('Velocity magnitude $U$ in rotated reference frame','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Velocity magnitude [m/s]','FontSize',f)
% hold off
% save the figure above
% % % savefig(fullfile(pname,dname,'VelMag_U.fig'));

% values of velocity for sanity check, comparable with the literature and excel (drop test in the office)
x_velo_avg = 10^-3*abs(x_centroid_rot(1) - x_centroid_rot(end))/(Time(end)-Time(1));
y_velo_avg = 10^-3*abs(y_centroid_rot(1) - y_centroid_rot(end))/(Time(end)-Time(1));
z_velo_avg = 10^-3*abs(z_centroid_rot(1) - z_centroid_rot(end))/(Time(end)-Time(1));
U_velo_avg = sqrt(x_velo_avg.^2 + y_velo_avg.^2 + z_velo_avg.^2);

% values requested by IMV for the table
Vel_table = [round(z_velo_avg,2) round(U_velo_avg,2)];
display(Vel_table)
% ï»¿Flight of a samara, Alsomitra macrocarpa Azuma and Okuno
% Table 3 Flight speed = 1.52[m/s], Rate of descent = 0.41[m/s] 

FlightSpeed = 1.52;
RateDescent = 0.41;

% percentage difference from experiment to Azuma and Okuno
U_FlightSpeed = 100*(FlightSpeed - U_velo_avg)/FlightSpeed;
w_RateDescent = 100*(RateDescent - z_velo_avg)/RateDescent;

% accelerations [m/s^2], derivative of fitted functions
% x_acc = gradient(x_velo,dt);
% y_acc = gradient(y_velo,dt);
% z_acc = gradient(z_velo,dt);
% A_acc = sqrt(x_acc.^2+y_acc.^2+z_acc.^2);

% accelerations [m/s^2], finite differences scheme
x_acc_FinDiff = gradient(x_velo_FinDiff,dt);%x_acc_FinDiff = diff(x_velo_FinDiff)/dt;
y_acc_FinDiff = gradient(y_velo_FinDiff,dt);%y_acc_FinDiff = diff(y_velo_FinDiff)/dt;
z_acc_FinDiff = gradient(z_velo_FinDiff,dt);%z_acc_FinDiff = diff(z_velo_FinDiff)/dt;
A_acc_FinDiff = sqrt(x_acc_FinDiff.^2 + y_acc_FinDiff.^2 + z_acc_FinDiff.^2);

figure
% plot(Time_2,x_acc/10^3,Time_2,y_acc/10^3,Time_2,z_acc/10^3)
% hold on
plot(Time_2,fitfxx/10^3,Time_2,fitfyy/10^3,Time_2,fitfzz/10^3)
yline(0)
title('Acceleration in rotated reference frame','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Acceleration components [m/s$^{2}$]','FontSize',f)
legend('$a_{y}$','$a_{x}$','$a_{z}$','FontSize',f)
% hold off
% save the figure above
% % % savefig(fullfile(pname,dname,'AccComp.fig'));

figure
% plot(Time_2,x_acc/10^3,'b',Time_2,fitfxx/10^3,'k',Time,x_acc_FinDiff/10^3,'.k')
plot(Time_2,fitfxx/10^3,'k',Time,x_acc_FinDiff/10^3,'.k')
title('Acceleration component $a_{y}$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Acceleration component $a_{y}$ [m/s$^{2}$]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AccComp_x.fig'));

figure
% plot(Time_2,y_acc/10^3,'r',Time_2,fitfyy/10^3,'k',Time,y_acc_FinDiff/10^3,'.k')
plot(Time_2,fitfyy/10^3,'k',Time,y_acc_FinDiff/10^3,'.k')
title('Acceleration component $a_{x}$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Acceleration component $a_{x}$ [m/s$^{2}$]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AccComp_y.fig'));

figure
% plot(Time_2,z_acc/10^3,'g',Time_2,fitfzz/10^3,'k',Time,z_acc_FinDiff/10^3,'.k')
plot(Time_2,fitfzz/10^3,'k',Time,z_acc_FinDiff/10^3,'.k')
title('Acceleration component $a_{z}$, fitting and finite difference','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Acceleration component $a_{z}$ [m/s$^{2}$]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AccComp_z.fig'));

figure
% plot(Time_2,fitfA/10^3,Time_2,A_acc/10^3,Time,A_acc_FinDiff/10^3,'.k')
plot(Time_2,fitfA/10^3,Time,A_acc_FinDiff/10^3,'.k')
title('Acceleration magnitude in rotated reference frame','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Acceleration magnitude [m/s$^{2}$]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AccMag_A.fig'));

% Forces 
% Alsomitra's mass from Excel file, I need to measure the mass of
% Alsomitras between 25 and 32, in the meantime I use the mean value
load m_alsomitra;
% mass in [kg]
m_alsomitra = mean(m_alsomitra(1:24))/10^3;

% Force on the x axis, Fx
F_x = m_alsomitra*fitfxx;
% Force on the y axis, Fy
F_y = m_alsomitra*fitfyy;
% Force on the z axis, Fz. Buoyancy is negligible
g = 9.81;
F_z = m_alsomitra*(fitfzz+g);
% total force
F_total = sqrt(F_x.^2 + F_y.^2 + F_z.^2);


% theta [rad]
theta_diff = atan(diff(z_centroid_rot)./sqrt(diff(x_centroid_rot).^2+diff(y_centroid_rot).^2));
theta_grad = atan(gradient(z_centroid_rot,dt)./sqrt(gradient(x_centroid_rot,dt).^2+gradient(y_centroid_rot,dt).^2));
% theta_fit = atan(diff(z_filt)./sqrt(diff(x_filt).^2+diff(y_filt).^2));

figure
plot(Time(1:end-1),theta_diff','og')
hold on
plot(Time,theta_grad','.k')
% plot(Time_2(1:end-1),theta_fit,'k')
title('Theta $\theta$','FontSize',f)
xlabel('time [s]','FontSize',f)
ylabel('$\theta$ [rad]','FontSize',f)
% % % savefig(fullfile(pname,dname,'Theta.fig'));
hold off

% theta prime [rad/s]
theta_prime = gradient(theta_grad,dt);

figure
plot(Time,theta_prime,'ok')
title('Theta differentiation','FontSize',f)
xlabel('time [s]','FontSize',f)
ylabel('$\dot{\theta}$ [rad/s]','FontSize',f)
% % % savefig(fullfile(pname,dname,'Theta_prime.fig'));

% % % %remove the commented toc() at the end
% % % toc();

% allocating array of struct
% nomestruttura(dimensione).campo1 = [];
GOF_PLANE(fin-in+1).sse = [];
GOF_PLANE(fin-in+1).rsquare = [];
GOF_PLANE(fin-in+1).dfe = [];
GOF_PLANE(fin-in+1).adjrsquare = [];
GOF_PLANE(fin-in+1).rmse = [];

% allocating vectors for next for loop
AngleXY = zeros(1,fin-in+1);
AngleXZ = zeros(1,fin-in+1);
AngleYZ = zeros(1,fin-in+1);

% https://uk.mathworks.com/help/vision/ref/pctransform.html
% rotation of the denoised point cloud around Z axis, vertical axis is Z.
% angle between the straight line and the YZ plane, it is a constant 

ThetaInRadians = deg2rad(ThetaInDegrees);
    
% rotation matrix around X axis
% https://uk.mathworks.com/help/images/matrix-representation-of-geometric-transformations.html
RZ = [ cos(ThetaInRadians), sin(ThetaInRadians), 0, 0;
      -sin(ThetaInRadians), cos(ThetaInRadians), 0, 0;
                         0,                   0, 1, 0;
                         0,                   0, 0, 1];
    
tformRZ = affine3d(RZ);

%% make plots for the angles, set a threshold for gof and fit the discrete values.
for m = 1:fin-in+1
% to fit a plane we need 3 points
    if ptCloudDeNoisePoints(m) <= 3
       continue
    end

    % transformation of the denoised point cloud, in use
    ptCloudRotZ = pctransform(PTCLOUDDENOISE(1,m), tformRZ);
    % transformation of the full point cloud
    ptCloudFullRotZ = pctransform(ROTPTCLOUD(1,m), tformRZ);
    
    % fitting a plane to the denoised and rotated point cloud
    [fo_plane, gof_plane] = fit([ptCloudRotZ.Location(:,1),ptCloudRotZ.Location(:,2)],ptCloudRotZ.Location(:,3),'poly11');
    GOF_PLANE(m) = gof_plane;
    
    % save adjrsquare as a vector
    plane_fit_adjrsquare = [GOF_PLANE(:).adjrsquare];
    Normal = [-fo_plane.p10, -fo_plane.p01, 1];
    
    % add a condition on adj rsquare, if it is below 0.5 do not use the value
    Fit_threshold = 0.5;
%     plot(AngleXY(plane_fit_adjrsquare >= Fit_threshold),'.')

    % angle between the plane fitting Alsomitra and the horizontal plane XY
    den_ang = sqrt(fo_plane.p10^2 + fo_plane.p01^2 + (-1)^2);
    AngleXY(m) = round(rad2deg(acos(abs(-1)./den_ang)),0);
    AngleXZ(m) = round(rad2deg(acos(abs(fo_plane.p01)./den_ang)),0);
    AngleYZ(m) = round(rad2deg(acos(abs(fo_plane.p10)./den_ang)),0);
    
    % magnifying factor 
    int = 1000;
    % rotation around Z axis of the denoised point cloud
    figure
    pcshow(ptCloudFullRotZ.Location,[0.5 0.5 0.5])
    hold on
    pcshow(ptCloudRotZ.Location,[1 0 0]);
    plot(fo_plane)
    % plot normal to the plane
    quiver3(mean(ptCloudRotZ.Location(:,1)),mean(ptCloudRotZ.Location(:,2)),mean(ptCloudRotZ.Location(:,3)),int*Normal(1),int*Normal(2),int*Normal(3),'r');
    axis([-1500 1500 -1500 1500 -1500 1500])
    title(['Plane fitted',' ',num2str(j)],'FontSize',f)
    xlabel('$y$ [mm]','FontSize',f) %xlabel('x [mm]')
    ylabel('$x$ [mm]','FontSize',f) %ylabel('y [mm]')
    zlabel('$z$ [mm]','FontSize',f) %zlabel('z [mm]')
    hold off 
    
    % pcfitcuboid to get the Euler angles, it does not work
%     ptCloud_cuboid = pcfitcuboid(ptCloudRotZ);
%     ptCloud_cuboid_angles(m,:) = ptCloud_cuboid.Orientation;
%     % save ptCloud_cuboid.Orientation
%     figure
%     plot(ptCloud_cuboid) 
%     hold on
%     pcshow(ptCloudRotZ.Location,[0 1 0]);
%     axis([-1500 1500 -1500 1500 -1500 1500])
%     title(['Rotation Z axis',' ',num2str(j)])
%     xlabel('x [mm]')
%     ylabel('y [mm]')
%     zlabel('z [mm]')
%     hold off 
end

%% adjusted the plotted angle, it cannot be 90 deg, maybe it is angle -90
% figure of adjrsquare to have an idea
figure
plot(plane_fit_adjrsquare,'.')
yline(Fit_threshold,'r')
title('adjrsquare for plane fitting of the denoised point cloud','FontSize',f)
xlabel('Frames','FontSize',f)
ylabel('adjrsquare','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'adjrsquare.fig'));

% percentage of frames above threshold
PerAngGoodFrames = 100*numel(plane_fit_adjrsquare(plane_fit_adjrsquare > Fit_threshold))/(fin-in+1);

% these three lines seem useless
% % % AngleXY(plane_fit_adjrsquare >= Fit_threshold);
% % % AngleXZ(plane_fit_adjrsquare >= Fit_threshold);
% % % AngleYZ(plane_fit_adjrsquare >= Fit_threshold);

% time specific to plot the angles,depending on the Fit_threshold chosen
% the size of vectors AngleXY, AngleXZ, AngleYZ.
Time_Angle = linspace(0,Dt,numel(AngleXY));
% plots for the angles
figure
plot(Time_Angle,AngleXY,'.k',Time_Angle(plane_fit_adjrsquare >= Fit_threshold),AngleXY(plane_fit_adjrsquare >= Fit_threshold),'or')
title('Angle between plane fitting Alsomitra and XY plane, horizontal','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Angle with XY [deg]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AngleXY.fig'));

%% Switched X and Y
% plots for the angles
figure
plot(Time_Angle,AngleXZ,'.k',Time_Angle(plane_fit_adjrsquare >= Fit_threshold),AngleXZ(plane_fit_adjrsquare >= Fit_threshold),'or')
title('Angle between plane fitting Alsomitra and YZ plane, vertical','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Angle with YZ [deg]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AngleXZ.fig'));

% plots for the angles
figure
plot(Time_Angle,AngleYZ,'.k',Time_Angle(plane_fit_adjrsquare >= Fit_threshold),AngleYZ(plane_fit_adjrsquare >= Fit_threshold),'or')
title('Angle between plane fitting Alsomitra and XZ plane, lateral','FontSize',f)
xlabel('Time [s]','FontSize',f)
ylabel('Angle with XZ [deg]','FontSize',f)
% save the figure above
% % % savefig(fullfile(pname,dname,'AngleYZ.fig'));

toc();